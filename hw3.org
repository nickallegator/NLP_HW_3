#+title: Homework 3:  Machine Learning for Language Understanding
#+author: Toni Kazic
#+date: Fall, 2025

# <2023-10-24 Tue>


#+SETUPFILE: "../../../common/preamble.org"
#+LATEX_CLASS: article
#+OPTIONS: toc:nil
#+OPTIONS: ^:nil

#+LATEX_HEADER: \usepackage{langsci-avm}
# http://ftp.math.purdue.edu/mirrors/ctan.org/macros/latex/contrib/langsci-avm/langsci-avm.pdf

#+LATEX_HEADER: \newcommand{\grmr}[2]{\ensuremath{\mathrm{#1} & \,\longrightarrow\, \mathrm{#2}}}
#+LATEX_HEADER: \newcommand{\txtgrmr}[2]{\ensuremath{\mathrm{#1} \,\longrightarrow\, \mathrm{#2}}}
#+LATEX_HEADER: \newcommand{\grmrhs}[1]{\ensuremath{& \,\longrightarrow\, \mathrm{#1} }}
#+LATEX_HEADER: \newcommand{\wa}[1]{\type{\textnormal{\w{#1}}}}

# compile with pdflatex
#
# Kazic, 3.11.2020



* DONE Introduction

This homework explores the course objective of understanding and
generating machine learning approaches, taking us into (shallow) machine
learning for language understanding. This will give us a chance to consider
the problem of usefully embedding language in numerically defined spaces,
giving us a chance to compare a seat-of-the-pants approach to the more
sophisticated ones we discussed in class.  It also gives us an opportunity
to compare different classifiers for different corpora and get an idea of
how well they perform.


NLTK has some classifiers, but [[http://scikit-learn.org/stable/user_guide.html][scikit-learn]] has more (so be sure to install
any needed modules!).  Let's jump off the deep end together and see how
far we can get.



# We'll revisit the feature extraction problem in the future, so
# this homework explores how well guessed features perform.

# At the end we look briefly at checking coherence using bags of
# words (see [[http://www.nltk.org/book/ch06.html][Section 2.3 ff]] for a short discussion and examples).  This is
# one technique for recognizing textual entailment.




* DONE Who's Who and Solution Patterns
<<whoswho>>

** Lead Person:  green


** Group Members

| first name last name | color                         |
|----------------------+-------------------------------|
|Nick Allegretti       | green \color{green}\rule{5mm}{3mm} |
|Dan Sparks            | yellow \color{yellow}\rule{5mm}{3mm} |
|Rohitha               | purple \color{violet}\rule{5mm}{3mm} |



** *Special Instructions for this Homework!*

All group members are to work on problem 6 together.  I want you to have
enough scope to play around with the embeddings and clustering algorithms.

Corpus: reuters


** Three Member Solution Patterns

$i$ is the question number.

#+begin_center
#+ATTR_LaTeX: :mode inline-math :environment array
| \text{color}                  | \text{draft solution} | \text{revise solution} |
|-------------------------------+----------------+-----------------|
| green \color{green}\rule{5mm}{3mm} | i \mod 3 = 1   | i \mod 3 = 0    |
| yellow \color{yellow}\rule{5mm}{3mm} | i \mod 3 = 2   | i \mod 3 = 1    |
| purple \color{violet}\rule{5mm}{3mm} | i \mod 3 = 0   | i \mod 3 = 2    |
#+end_center

** Two Member Solution Patterns

| color                         | draft solution | revise solution |
|-------------------------------+----------------+-----------------|
| green \color{green}\rule{5mm}{3mm} | odds           | evens           |
| yellow \color{yellow}\rule{5mm}{3mm} | evens          | odds            |




* DONE General Instructions
  + /Fill out the group members table and follow the solution patterns/ in
     Section [[whoswho]].

   + /If the question is unclear, tell me your interpretation of it as part
     of your answer./  Feel free to ask about the questions in class or on
     the Slack channel (use =@channel= as others will probably be puzzled
     too). 

   + /For questions using corpora, use the corpus of the lead person./

   + /Put your draft answers right after each question using a *complete,
     functional* =org= mode code or example block./ Make sure your code
     block is complete and functional by testing it in your copy of this
     homework file.

   + /Each group member reviews the others' draft solutions and you revise them together/.

   + /Discuss each other's draft and reviews, finalizing the answers./

   + /Show all your work: code, results, and analysis./  Does your code
     work in this file and produce *exactly* the results you show? 

   + /Post the completed file to Canvas no later than noon on the Tuesday
     indicated/ in the [[../syllabus.org::schedule][schedule in the syllabus]], naming your file with each
     person's first name (no spaces in the file name, and don't forget the
     =.org= extension!).  Only one person should submit the final file.


* DONE Hints


** joblib.dump() and joblib.load()

Note that for big data, the [[http://scikit-learn.org/stable/tutorial/basic/tutorial.html][scikit-learn tutorial]] suggests using
joblib.dump() and joblib.load().  However this only writes to disk, not a
string, but can store models and classifiers.


** I expect you to bring questions and struggles with problems 4 and 5 to class!


** You may need to reformat the data generated by NLTK for the [[http://scikit-learn.org/stable/modules/feature_extraction.html][scikit-learn code]].


** You may need to cope with [[http://scikit-learn.org/stable/auto_examples/text/document_classification_20newsgroups.html#sphx-glr-auto-examples-text-document-classification-20newsgroups-py][sparse data]] in scikit-learn.

One reason to use the universal tagset is that it doesn't have very many
tags, but depending on your corpus, your suffixes may have more than is
really desirable for problem 4.




* DONE Questions

# revised for exclusions for 2024
#
# Kazic, 12.12.2023

1. [@1] <<tagging>> Randomly select 1000 POS-tagged words from your
   assigned category/corpus and form your training and testing sets so that
   you train on 90% of the words and test on 10%.  Exclude stop words,
   numbers, and words of length three or less. Use the universal POS
   tagset. *If your corpus isn't tagged, choose a tagged corpus.* Using a
   tagger to tag it won't help much as it doesn't make a gold standard
   (that requires hand-checking by expert grammarians).  Save these somehow
   so you can re-use them in the [[fea-set][next]] problem.

   #+begin_example
   Reuters is not POS tagged.
   Using Brown instead.
   Using News category since no assigned category.
   #+end_example

   #+begin_src python :results output
     import random
     import re
     import json

     import nltk
     from nltk.corpus import brown, stopwords


     def is_number_token(word):
         number_pattern = re.compile(r"^\d+(\.\d+)?$")
         return bool(number_pattern.match(word))

     def main():
         nltk.download("brown")
         nltk.download("universal_tagset")
         nltk.download("stopwords")

         # No assigned category using news
         brown_category = "news"
         n_samples = 1000
         train_ratio = 0.9

         # Load tagged words
         tagged_words = brown.tagged_words(
             categories=brown_category,
             tagset="universal"
         )
         print(
             "Total tagged tokens in Brown {}: {}".format(
                 brown_category, len(tagged_words)
             )
         )

         english_stops = set(stopwords.words("english"))

         filtered = []
         for (word, tag) in tagged_words:
             w_lower = word.lower()

             # Exclude stopwords
             if w_lower in english_stops:
                 continue

             # Exclude short words
             if len(word) <= 3:
                 continue

             # Exclude numbers
             if is_number_token(word) or tag == "NUM":
                 continue

             filtered.append((word, tag))

         print("Tokens after filtering: {}".format(len(filtered)))

         if len(filtered) < n_samples:
             raise ValueError(
                 "Not enough tokens after filtering ({} found, need at least {})."
                 .format(len(filtered), n_samples)
             )

         # Random sample of 1000 tokens
         random.seed(42)      # for reproducibility
         sample = random.sample(filtered, n_samples)
         random.shuffle(sample)

         # Train / test split
         train_size = int(train_ratio * n_samples)
         train_data = sample[:train_size]
         test_data = sample[train_size:]

         print("Train size: {}".format(len(train_data)))
         print("Test size:  {}".format(len(test_data)))

         # print("First 5 train examples:", train_data[:5])
         # print("First 5 test examples:", test_data[:5])

         #Save to JSON for use in other questions
         json_train = [{"word": w, "tag": t} for (w, t) in train_data]
         json_test = [{"word": w, "tag": t} for (w, t) in test_data]

         output = {
             "corpus": "brown",
             "category": brown_category,
             "n_samples": n_samples,
             "train": json_train,
             "test": json_test,
         }

         out_file = "brown_news_pos_splits.json"
         with open(out_file, "w", encoding="utf-8") as f:
             json.dump(output, f, indent=2)

         print("Saved train/test data to {}".format(out_file))

     if __name__ == "__main__":
         main()


   #+end_src
   #+RESULTS:
   : Total tagged tokens in Brown news: 100554
   : Tokens after filtering: 45840
   : Train size: 900
   : Test size:  100
   : Saved train/test data to brown_news_pos_splits.json
   


# amended to remove confusing dictionary suggestion
#
# Kazic, 3.12.2024

2. [@2] <<fea-set>> For each of tuples in your training set in problem
   [[tagging]], extract the last *three /letters/ for the word* and its entire
   tag, and compile these into an NLTK feature set.  Check to see if the
   same feature is mapped to more than one tag and if so, then retag that
   feature with 'X'.  Again, save the feature set for reuse as a file.  *Do
   the same for the test set.*

#+begin_src python :results output
import json
import nltk
from collections import defaultdict

# extract last 3 letters as features and their tags
def extract_features_and_check_conflicts(tagged_words, dataset_name):
    feature_to_tags = defaultdict(set)
    feature_set = []


    # first pass
    for word, tag in tagged_words:
        suffix = word[-3:].lower()
        feature_to_tags[suffix].add(tag)

    # Find conflicting features (mapped to more than one tag)
    conflicting_features = {feat for feat, tags in feature_to_tags.items() if len(tags) > 1}

    print('Dataset: {}'.format(dataset_name))
    print('Total unique suffixes: {}'.format(len(feature_to_tags)))
    print('Conflicting suffixes: {}'.format(len(conflicting_features)))

    if conflicting_features:
        print('Examples of conflicting suffixes and their tags:')
        for feat in list(conflicting_features)[:5]:
            print('  Suffix: {}, Tags: {}'.format(feat, feature_to_tags[feat]))

    # second pass

    for word, tag in tagged_words:
        suffix = word[-3:].lower()

        if suffix in conflicting_features:
            final_tag = 'X'
        else:
            final_tag = tag

        features = {'suffix': suffix}
        feature_set.append((features, final_tag))

    return feature_set, conflicting_features

def main():
    with open('brown_news_pos_splits.json', 'r') as f:
        data = json.load(f)

    train_data = [(item['word'], item['tag']) for item in data['train']]
    test_data = [(item['word'], item['tag']) for item in data['test']]

    print('Loaded {} training samples and {} test samples.'.format(len(train_data), len(test_data)))

    #process training set
    train_feature_set, train_conflicts = extract_features_and_check_conflicts(train_data, 'Training')

    test_feature_set, test_conflicts = extract_features_and_check_conflicts(test_data, 'Test')

    print('\nFeature set examples (first 5 from training):')
    for i, (features, tag) in enumerate(train_feature_set[:5]):
        print('  {} -> {}'.format(features, tag))

    train_output = {
        'feature_set': train_feature_set,
        'conflicting_suffixes': list(train_conflicts),
        'dataset': 'training'
    }

    test_output = {
        'feature_set': test_feature_set,
        'conflicting_features': list(test_conflicts),
        'dataset': 'test'
    }

    with open('train_features.json', 'w', encoding='utf-8') as f:
        #serialize
        serializable_train = {
            'feature_set': [(dict(feat), tag) for feat, tag in train_feature_set],
            'conflicting_features': list(train_conflicts),
            'dataset': 'training'
        }
        json.dump(serializable_train, f, indent=2)

    with open('test_features.json', 'w', encoding='utf-8') as f:
       # serializable
        serializable_test = {
            'feature_set': [(dict(feat), tag) for feat, tag in test_feature_set],
            'conflicting_features': list(test_conflicts),
            'dataset': 'test'
        }
        json.dump(serializable_test, f, indent=2)

    print('\nFeature sets saved to train_features.json and test_features.json')

    #summary
    print('\nSummary:')
    print('training set: {} features, {} retagged as X'.format(len(train_feature_set), sum(1 for _, tag in train_feature_set if tag == 'X')))
    print('test set: {} features, {} retagged as X'.format(len(test_feature_set), sum(1 for _, tag in test_feature_set if tag == 'X')))


if __name__ == "__main__":
    main()

#+end_src
#+RESULTS:
#+begin_example
Loaded 900 training samples and 100 test samples.
Dataset: Training
Total unique suffixes: 370
Conflicting suffixes: 73
Examples of conflicting suffixes and their tags:
  Suffix: ast, Tags: {'ADJ', 'NOUN', 'ADP'}
  Suffix: ate, Tags: {'ADJ', 'NOUN'}
  Suffix: ood, Tags: {'NOUN', 'ADJ'}
  Suffix: all, Tags: {'ADJ', 'NOUN'}
  Suffix: r's, Tags: {'NOUN', 'DET'}
Dataset: Test
Total unique suffixes: 82
Conflicting suffixes: 1
Examples of conflicting suffixes and their tags:
  Suffix: ing, Tags: {'NOUN', 'VERB'}

Feature set examples (first 5 from training):
  {'suffix': 'ing'} -> X
  {'suffix': 'are'} -> NOUN
  {'suffix': 'uns'} -> NOUN
  {'suffix': 'tly'} -> ADV
  {'suffix': 'ile'} -> NOUN

Feature sets saved to train_features.json and test_features.json

Summary:
training set: 900 features, 341 retagged as X
test set: 100 features, 3 retagged as X
#+end_example


3. [@3] <<bayesian>> Now train a naive Bayes classifier using the one in
   NLTK or scikit-learn on your saved [[fea-set][feature set]] and show its accuracy.
   Show the ten most informative features (for sure you can get this from
   the NLTK naive Bayes classifier).

      #+begin_src python :results output
import json
import nltk
from nltk.classify import NaiveBayesClassifier
from collections import Counter, defaultdict


def load_feature_set(path):
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)

    feature_set = []
    for feat_dict, tag in data["feature_set"]:
        feature_set.append((feat_dict, tag))

    return feature_set


def show_custom_informative_suffixes(train_features, n=10):
    suffix_label_counts = defaultdict(Counter)
    label_counts = Counter()

    for feats, tag in train_features:
        suffix = feats["suffix"]
        suffix_label_counts[suffix][tag] += 1
        label_counts[tag] += 1

    # Overall label distribution
    total_labels = sum(label_counts.values())
    if total_labels == 0:
        print("\nCustom informative suffixes:")
        return

    label_probs = {label: count / total_labels for label, count in label_counts.items()}

    scores = []
    for suffix, counts in suffix_label_counts.items():
        total_suffix = sum(counts.values())
        if total_suffix == 0:
            continue

        for label, count in counts.items():
            p_l_given_suffix = count / total_suffix
            p_l = label_probs.get(label, 0.0)
            if p_l == 0.0:
                continue
            ratio = p_l_given_suffix / p_l
            scores.append(((suffix, label), ratio, count))

    # Sort by how much the suffix boosts the tag probability
    scores.sort(key=lambda x: x[1], reverse=True)

    print("\nCustom most informative suffixes:")
    if not scores:
        print("  (No informative suffixes found under this scoring scheme.)")
        return

    for (suffix, label), ratio, count in scores[:n]:
        print(f"suffix={suffix!r:>5} -> {label:>5}   ratio={ratio:6.2f}   count={count}")


def main():
    # Load previously saved feature sets
    train_features = load_feature_set("train_features.json")
    test_features = load_feature_set("test_features.json")

    print("Loaded {} training instances and {} test instances."
          .format(len(train_features), len(test_features)))

    # Train Naive Bayes classifier
    classifier = NaiveBayesClassifier.train(train_features)

    # Compute accuracy on train and test sets
    train_accuracy = nltk.classify.accuracy(classifier, train_features)
    test_accuracy = nltk.classify.accuracy(classifier, test_features)

    print("\nAccuracy:")
    print("  Training accuracy: {:.4f}".format(train_accuracy))
    print("  Test accuracy:     {:.4f}".format(test_accuracy))

    # NLTK's default most informative features only print the header due to Q2 retagging
    print("\nTen most informative features (NLTK view):")
    classifier.show_most_informative_features(10)

    # Custom informative suffix analysis
    show_custom_informative_suffixes(train_features, n=10)


if __name__ == "__main__":
    main()

      #+end_src
      #+RESULTS:
      #+begin_example
      Loaded 900 training instances and 100 test instances.

      Accuracy:
	Training accuracy: 0.9622
	Test accuracy:     0.6200

      Ten most informative features (NLTK view):
      Most Informative Features

      Custom most informative suffixes:
      suffix='ike' ->   ADP   ratio=450.00   count=2
      suffix='lus' ->  CONJ   ratio=450.00   count=2
      suffix='tly' ->   ADV   ratio= 52.94   count=2
      suffix='hus' ->   ADV   ratio= 52.94   count=1
      suffix='.m.' ->   ADV   ratio= 52.94   count=1
      suffix='lso' ->   ADV   ratio= 52.94   count=4
      suffix='lse' ->   ADV   ratio= 52.94   count=1
      suffix='nly' ->   ADV   ratio= 52.94   count=1
      suffix='ily' ->   ADV   ratio= 52.94   count=2
      suffix='oat' ->   ADV   ratio= 52.94   count=1
      #+end_example



4. [@4] <<lda>> Continuing with the Bayesian theme of problem [[bayesian]],
   let's try some [[http://scikit-learn.org/stable/modules/generated/sklearn.discriminant_analysis.LinearDiscriminantAnalysis.html#sklearn.discriminant_analysis.LinearDiscriminantAnalysis][linear discriminant analysis]] with the algorithm found in
   *scikit-learn*, using the tags in the saved [[fea-set][feature set]] as the labels we
   want to learn.  Again, the question we're asking is how well do the
   three-letter suffixes predict the tags, so this is a multiclass LDA
   problem; the example on the man page shows a two-class problem.  We'll
   use the default =svd= method with no shrinkage, both because it's a good
   place to start and because it may be able to cope with the size of our
   tag and feature sets.  Return the output of the =decision_function= and
   =score= functions after training and testing the classifier.  Compute
   the LDA with and without downcasing and compare and discuss the results.

 #+begin_src python
import json
import numpy as np
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.feature_extraction import DictVectorizer
from sklearn.metrics import classification_report
from collections import Counter


def load_feature_data():
    with open('train_features.json', 'r', encoding='utf-8') as f:
        train_data = json.load(f)

    with open('test_features.json', 'r', encoding='utf-8') as f:
        test_data = json.load(f)

    return train_data, test_data

def prepare_data(feature_set, vectorizer=None, fit_vectorizer=True):
    features = [feat_dict for feat_dict, _ in feature_set]
    labels = [tag for _, tag in feature_set]

    if vectorizer is None:
        vectorizer = DictVectorizer(sparse=False)

    if fit_vectorizer:
        X = vectorizer.fit_transform(features)

    else:
        X = vectorizer.transform(features)

    return X, labels, vectorizer

def run_lda_experiment(X_train, y_train, X_test, y_test, experiment_name):
    # run lda classification experiment
    print(f'\n== {experiment_name} ==')

    # lda classifier
    lda = LinearDiscriminantAnalysis(solver='svd')

    print(f'training LDA on {X_train.shape[0]} samples with {X_train.shape[1]} features...')
    lda.fit(X_train, y_train)

    # predictions output
    train_predictions = lda.predict(X_train)
    test_predictions = lda.predict(X_test)

    # decision and confidence

    train_decision = lda.decision_function(X_train)
    test_decision = lda.decision_function(X_test)

    # score and accuracy

    train_score = lda.score(X_train, y_train)
    test_score = lda.score(X_test, y_test)

    print(f'Training accuracy: {train_score:.4f}')
    print(f'Test accuracy: {test_score:.4f}')

    # classification report
    print('\nClassification Report:')
    print(classification_report(y_test, test_predictions, zero_division=0))

    # common tags print

    print('\nMost common predicted tags in test:')
    pred_counter = Counter(test_predictions)
    for tag, count in pred_counter.most_common(10):
        print(f'  {tag}: {count}')

    return {
        'lda_model': lda,
        'train_decision': train_decision,
        'test_decision': test_decision,
        'train_score': train_score,
        'test_score': test_score,
        'train_predictions': train_predictions,
        'test_predictions': test_predictions
    }

def create_downcased_features(feature_set):
    downcased_set = []
    for feat_dict, tag in feature_set:
        new_feat = feat_dict.copy()
        if 'suffix' in new_feat:
            new_feat['suffix'] = new_feat['suffix'].lower()
        downcased_set.append((new_feat, tag))
    return downcased_set

def main():
    print('Loading feature data from problem 2')
    train_data, test_data = load_feature_data()

    train_feature_set = train_data['feature_set']
    test_feature_set = test_data['feature_set']

    print(f'Loaded {len(train_feature_set)} training features')
    print(f'Loaded {len(test_feature_set)} test features')

    # show examples

    print('\nExample features:')
    for i in range(min(5, len(train_feature_set))):
        feat, tag = train_feature_set[i]
        print(f' {feat} -> {tag}')

    # experiment 1 with original features
    print('\n' + '='*50)
    print('EXPERIMENT 1: Original Features')
    print('='*50)

    X_train, y_train, vectorizer = prepare_data(train_feature_set)
    X_test, y_test, _ = prepare_data(test_feature_set, vectorizer, fit_vectorizer=False)

    results_exp1 = run_lda_experiment(X_train, y_train, X_test, y_test, "Experiment 1: Original Features")

    # experiment 2 with downcased features

    print('\n' + '='*50)
    print('EXPERIMENT 2: Downcased Features')
    print('='*50)

    train_downcased = create_downcased_features(train_feature_set)
    test_downcased = create_downcased_features(test_feature_set)

    X_train_down, y_train_down, vectorizer_down = prepare_data(train_downcased)
    X_test_down, y_test_down, _ = prepare_data(test_downcased, vectorizer_down, fit_vectorizer=False)

    results_exp2 = run_lda_experiment(X_train_down, y_train_down, X_test_down, y_test_down, "Experiment 2: Downcased Features")

    # results comparison

    print('\n' + '='*50)
    print("RESULTS COMPARISON")
    print('='*50)

    print(f'Experiment 1 Test Accuracy: {results_exp1["test_score"]:.4f}')
    print(f'Experiment 2 Test Accuracy: {results_exp2["test_score"]:.4f}')

    improvement = results_exp2["test_score"] - results_exp1["test_score"]
    print(f'Accuracy Improvement: {improvement:.4f}')

    print(f'\nFeature space sizes:')
    print(f' Experiment 1: {X_train.shape[1]} features')
    print(f' Experiment 2: {X_train_down.shape[1]} features')

    print(f'\nDecision function output:')
    print(f'Original - Train: {results_exp1["train_decision"].shape}, Test: {results_exp1["test_decision"].shape}')
    print(f'Downcased - Train: {results_exp2["train_decision"].shape}, Test: {results_exp2["test_decision"].shape}')

    #discussion prompt
    print('\nDiscussion:')
    print(f'- Downcasing {"improved" if improvement > 0 else "decreased"} accuracy by {abs(improvement):.4f}')
    print(f'- Feature space was {"reduced" if X_train_down.shape[1] < X_train.shape[1] else "same size"}')
    print(f'- This suggests that case {"does" if abs(improvement) > 0.01 else "does not"} significantly affect suffix-based POS tagging')

    if X_train.shape[1] < X_train_down.shape[1]:
        print(f'- Reducing feature space from {X_train_down.shape[1]} to {X_train.shape[1]} features')
        print(f'   helps reducing overfitting and improves generalization')

    # saving
    results_summary = {
        'original': {
            'train_accuracy': results_exp1['train_score'],
            'test_accuracy': results_exp1['test_score'],
            'feature_count': X_train.shape[1]
        },
        'downcased': {
            'train_accuracy': results_exp2['train_score'],
            'test_accuracy': results_exp2['test_score'],
            'feature_count': X_train_down.shape[1]
        },
        'improvement': improvement
    }

    with open('lda_experiment_results.json', 'w', encoding='utf-8') as f:
        json.dump(results_summary, f, indent=2)

    print('\nExperiment results saved to lda_experiment_results.json')

if __name__ == '__main__':
    main()
 #+end_src

 #+RESULTS:
 #+begin_example
 Loading feature data from problem 2
Loaded 900 training features
Loaded 100 test features

Example features:
 {'suffix': 'ing'} -> X
 {'suffix': 'are'} -> NOUN
 {'suffix': 'uns'} -> NOUN
 {'suffix': 'tly'} -> ADV
 {'suffix': 'ile'} -> NOUN

==================================================
EXPERIMENT 1: Original Features
==================================================

== Experiment 1: Original Features ==
training LDA on 900 samples with 370 features...
Training accuracy: 0.4933
Test accuracy: 0.6800

Classification Report:
              precision    recall  f1-score   support

         ADJ       0.00      0.00      0.00         9
         ADP       0.00      0.00      0.00         2
         ADV       1.00      0.25      0.40         4
        NOUN       0.67      1.00      0.80        64
        VERB       0.00      0.00      0.00        18
           X       1.00      1.00      1.00         3

    accuracy                           0.68       100
   macro avg       0.44      0.38      0.37       100
weighted avg       0.50      0.68      0.56       100


Most common predicted tags in test:
  NOUN: 96
  X: 3
  ADV: 1

==================================================
EXPERIMENT 2: Downcased Features
==================================================

== Experiment 2: Downcased Features ==
training LDA on 900 samples with 370 features...
Training accuracy: 0.4933
Test accuracy: 0.6800

Classification Report:
              precision    recall  f1-score   support

         ADJ       0.00      0.00      0.00         9
         ADP       0.00      0.00      0.00         2
         ADV       1.00      0.25      0.40         4
        NOUN       0.67      1.00      0.80        64
        VERB       0.00      0.00      0.00        18
           X       1.00      1.00      1.00         3

    accuracy                           0.68       100
   macro avg       0.44      0.38      0.37       100
weighted avg       0.50      0.68      0.56       100


Most common predicted tags in test:
  NOUN: 96
  X: 3
  ADV: 1

==================================================
RESULTS COMPARISON
==================================================
Experiment 1 Test Accuracy: 0.6800
Experiment 2 Test Accuracy: 0.6800
Accuracy Improvement: 0.0000

Feature space sizes:
 Experiment 1: 370 features
 Experiment 2: 370 features

Decision function output:
Original - Train: (900, 7), Test: (100, 7)
Downcased - Train: (900, 7), Test: (100, 7)

Discussion:
- Downcasing decreased accuracy by 0.0000
- Feature space was same size
- This suggests that case does not significantly affect suffix-based POS tagging

Experiment results saved to lda_experiment_results.json
 #+end_example

# two draws w/o replacement of anchors and successors; compare
# permute
# re-draw same anchors with new successors, and then compare all four



# rewritten <2023-10-31 Tue>

5. [@5] <<bow>> One feature that might be helpful in distinguishing
   machine-generated texts is repetition from sentence to sentence.  Let's
   explore that hypothesis informally.  One way we can approach that
   problem is by comparing significant words (that is, non-stop words)
   between each sentence and its successor sentence in a corpus.  We'll use
   the Brown corpus, category news, for this problem.  Go ahead and
   downcase unless you want to explain why you don't think it's a good
   idea.

    For 700 randomly selected sentences in the Brown news corpus (the
   ``first anchor sentences''), and their immediately succeeding sentences
   (''first set of successors''), form bags of the significant words for
   each pair of sentences (so really, these are paired data) and then
   compute the intersection between each pair of bags (so, 700 intersecting
   bags of words).  This is the baseline comparison.

   Tabulate these and compare the results to another randomly drawn 700
   sentences (''second anchor sentences''), ensuring that there are no
   duplicates between the first anchor sentences and the second anchor
   sentences and their successors (sampling without replacement).  Permute
   all sentences in the corpus, then draw the same second anchor sentences
   and their new successors and repeat computing the intersecting bags of
   significant words.   So you'll have three intersecting bags of
   significant words:
      + first anchor and their successors (overall baseline)
      + second anchor and their successors, ensuring that intersection of
        first and second anchors is empty (control for second anchors BOWs)
      + second anchor and new successors after permutation (the experiment).


   Compare and discuss the results.  You may use methods from NLTK,
   scikit-learn, or both for this problem: just be sure your code block is
   complete and self-contained.




# added notes on not relying on default cluster nums and
# checking quality of drawn data and enclosing plots
#
# Kazic, 13.12.2023
   
6. [@6] <<ml>> Choose 500 random sentences from the Brown news corpus
   tagged with the universal tagset.  For each sentence, identify the nouns
   and then compile a list of the three tags immediately preceeding each
   noun (excluding chunks smaller than three). (Ensure all your chosen
   sentences have at least one noun that occurs fourth or later in the
   list.)  Then encode each chunk in the list as a ternary tuple, mapping
   the tags to integers, and save the list of mapped tuples to disk using
   either pickle or json, as you wish.  Go ahead and downcase unless you
   want to explain why you don't think it's a good idea.

   Now cluster your saved encodings using the [[http://scikit-learn.org/stable/modules/generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift][MeanShift]] and
   [[https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering][AgglomerativeClustering]] algorithms from scikit-learn.  Do not rely on
   the default number of clusters for each method, but determine a good
   number of clusters for your data.  For MeanShift, take the remaining
   defaults; you may run it in parallel if you like and can.  Run
   AgglomerativeClustering thrice: first using "ward" for the linkage (it
   will only use a Euclidean metric); and then "average" for the linkage
   and "manhattan" and "cosine" for the metric.  Discuss the differences
   you find in the results of the different trials, referencing and
   enclosing your plots.





* DONE Grading Scale

This homework is worth 15 points. The grading scale is:


| fraction correctly reviewed and answered | points awarded |
|------------------------------------------+----------------|
| \(\ge 0.95\)                             |             15 |
| 0.90 -- 0.94                             |             14 |
| 0.85 -- 0.89                             |             13 |
| 0.80 -- 0.84                             |             12 |
| 0.75 -- 0.79                             |             11 |
| 0.70 -- 0.74                             |             10 |
| 0.65 -- 0.69                             |              9 |
| 0.60 -- 0.64                             |              8 |
| 0.55 -- 0.59                             |              7 |
| 0.50 -- 0.54                             |              6 |
| 0.45 -- 0.49                             |              5 |
| 0.40 -- 0.44                             |              4 |
| 0.35 -- 0.39                             |              3 |
| 0.30 -- 0.34                             |              2 |
| 0.25 -- 0.29                             |              1 |
| \(< 0.25\)                               |              0 |








* DONE Scoring


|     question | max pts | answer ok? |
|--------------+---------+------------|
|            1 |       1 |            |
|            2 |       1 |            |
|            3 |       2 |            |
|            4 |       2 |            |
|            5 |       2 |            |
|            6 |       7 |            |
|--------------+---------+------------|
|  total score |      15 |            |
|   percentage |         |            |
| total points |         |            |
#+TBLFM: @8$2=vsum(@I..@II)::@8$3=vsum(@I..@II)::@9$3=@-1/@-1$-1



